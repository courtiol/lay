% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lay.R
\name{lay}
\alias{lay}
\title{Apply a function within each row.}
\usage{
lay(.data, .fn, ..., .method = "apply")
}
\arguments{
\item{.data}{A data frame or tibble (or other data frame extensions).}

\item{.fn}{A function to apply to each row of \code{.data}.
Possible values are:
\itemize{
\item A function, e.g. \code{mean}
\item A purrr-style lambda, e.g. \code{~ mean(.x, na.rm = TRUE)}

(wrap the output in a data frame to apply several functions at once, e.g.
\code{~ tibble(min = min(.x), max = max(.x))})
}}

\item{...}{Additional arguments for the function calls in \code{fn}.}

\item{.method}{This is an experimental argument that allows you to control which internal method
is used to apply the rowwise job:
\itemize{
\item "apply", the default internally uses the function \code{\link[=apply]{apply()}}.
\item "tidy", internally uses \code{\link[purrr:map2]{purrr::pmap()}} and is stricter with respect to class coercion
across columns.
}

The default has been chosen based on these \href{../doc/benchmark.html}{\strong{benchmarks}}.}
}
\description{
Create efficiently new column(s) in data frame (including tibble) by applying a function one row at
a time.
}
\details{
\code{lay()} create a vector or a data frame (/tibble), by considering in turns each row of a data
frame (\code{.data}) as the vector input of some function(s) \code{.fn}.

This makes the creation of new columns based on a rowwise operation both simple (see
\strong{Examples}; below) and efficient (see the vignette \href{../doc/benchmark.html}{\strong{benchmarks}}).

The function should be fully compatible with \code{{dplyr}}-based workflows and follows a syntax close
to \code{\link[dplyr:across]{dplyr::across()}}.

Yet, it takes \code{.data} instead of \code{.cols} as a main argument, which makes it possible to also use
\code{lay()} outside \code{dplyr} verbs (see \strong{Examples}).

The function \code{lay()} should work in a wide range of situations, provided that:
\itemize{
\item The input \code{.data} should be a data frame (including tibble) with columns of same class, or of
classes similar enough to be easily coerced into a single class. Note that \code{.method = "apply"}
also allows for the input to be a matrix and is more permissive in terms of data coercion.
\item The output of \code{.fn} should be a scalar (i.e. vector of length 1) or a 1 row data frame (or
tibble).
}
}
\examples{

usage without dplyr -------------------------------------------------------------------------

# lay can return a vector
lay(iris[1:5, c("Sepal.Length", "Sepal.Width")], mean)

# lay can return a data frame
lay(iris[1:5, c("Sepal.Length", "Sepal.Width")],
   function(.x) data.frame(Min = min(.x), Mean = mean(.x), Max = max(.x)))

# lay can be used to augment a data frame
lay(iris[1:5, c("Sepal.Length", "Sepal.Width")],
   function(.x) cbind(iris[1:5, ], data.frame(Min = min(.x), Mean = mean(.x), Max = max(.x))))


usage with dplyr ----------------------------------------------------------------------------

if (require("dplyr")) {

  # for enhanced printing
  iris <- as_tibble(iris)

  # apply mean for each row
  iris \%>\%
    mutate(Sepal.Mean = lay(across(starts_with("Sepal")), mean))

  # not that useful because there is `rowMeans` already
  iris \%>\%
    mutate(Sepal.Mean = rowMeans(across(starts_with("Sepal"))))

  # but then we can lay other functions, e.g. median
  iris \%>\%
    mutate(Sepal.Median = lay(across(starts_with("Sepal")), median))

  # you can pass arguments to the function
  iris_with_NA <- iris
  iris_with_NA[1, 1] <- NA
  iris_with_NA \%>\%
    mutate(Sepal.Mean = lay(across(starts_with("Sepal")), mean))
  iris_with_NA \%>\%
    mutate(Sepal.Mean = lay(across(starts_with("Sepal")), mean, na.rm = TRUE))

  # you can also lay into a tibble if you want multiple results
  iris \%>\%
    mutate(Sepal.Mean = lay(
      across(starts_with("Sepal")),
      ~ tibble(Min = min(.x), Mean = mean(.x), Max = max(.x))
    ))

  # the previous example creates a df-column called `Sepal.Mean`,
  # which you could unpack with `tidyr::unpack()`, but
  # if you skip `Sepal.Mean =` things get auto spliced for you!
  iris \%>\%
    mutate(lay(
      across(starts_with("Sepal")),
      ~ tibble(Min = min(.x), Mean = mean(.x), Max = max(.x))
    ))

  # if your function returns a vector and not a scalar,
  # just wrap it up in list (note also the use of the lambda syntax ~ fn(.x) here)
  iris \%>\%
    mutate(Sepal.Quantiles = lay(across(starts_with("Sepal")), ~ list(quantile(.x))))

  # the previous example creates a list-column called `Sepal.Quantiles`,
  # which you could unnest with `tidyr::unnest_wider()`, but
  # you can once again rely on a tibble and skip the column name to get the output
  # auto spliced for you!
  iris \%>\%
    mutate(lay(across(starts_with("Sepal")), ~ as_tibble_row(quantile(.x))))
}

}
